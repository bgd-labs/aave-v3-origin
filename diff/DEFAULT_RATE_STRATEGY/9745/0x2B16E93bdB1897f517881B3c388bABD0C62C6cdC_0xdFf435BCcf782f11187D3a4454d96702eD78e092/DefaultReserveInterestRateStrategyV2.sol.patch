Index: src/contracts/misc/DefaultReserveInterestRateStrategyV2.sol
===================================================================
--- src/contracts/misc/DefaultReserveInterestRateStrategyV2.sol
+++ src/contracts/misc/DefaultReserveInterestRateStrategyV2.sol
@@ -50,9 +50,9 @@
 
     modifier onlyPoolConfigurator() {
         require(
             msg.sender == ADDRESSES_PROVIDER.getPoolConfigurator(),
-            Errors.CallerNotPoolConfigurator()
+            Errors.CALLER_NOT_POOL_CONFIGURATOR
         );
         _;
     }
 
@@ -60,9 +60,9 @@
      * @dev Constructor.
      * @param provider The address of the PoolAddressesProvider of the associated Aave pool
      */
     constructor(address provider) {
-        require(provider != address(0), Errors.InvalidAddressesProvider());
+        require(provider != address(0), Errors.INVALID_ADDRESSES_PROVIDER);
         ADDRESSES_PROVIDER = IPoolAddressesProvider(provider);
     }
 
     /// @inheritdoc IReserveInterestRateStrategy
@@ -146,14 +146,20 @@
     }
 
     /// @inheritdoc IReserveInterestRateStrategy
     function calculateInterestRates(
-        DataTypes.CalculateInterestRatesParams calldata params
+        DataTypes.CalculateInterestRatesParams memory params
     ) external view virtual override returns (uint256, uint256) {
         InterestRateDataRay memory rateData = _rayifyRateData(
             _interestRateData[params.reserve]
         );
 
+        // @note This is a short circuit to allow mintable assets (ex. GHO), which by definition cannot be supplied
+        // and thus do not use virtual underlying balances.
+        if (!params.usingVirtualBalance) {
+            return (0, rateData.baseVariableBorrowRate);
+        }
+
         CalcInterestRatesLocalVars memory vars;
 
         vars.currentLiquidityRate = 0;
         vars.currentVariableBorrowRate = rateData.baseVariableBorrowRate;
@@ -211,28 +217,28 @@
     function _setInterestRateParams(
         address reserve,
         InterestRateData memory rateData
     ) internal {
-        require(reserve != address(0), Errors.ZeroAddressNotValid());
+        require(reserve != address(0), Errors.ZERO_ADDRESS_NOT_VALID);
 
         require(
             rateData.optimalUsageRatio <= MAX_OPTIMAL_POINT &&
                 rateData.optimalUsageRatio >= MIN_OPTIMAL_POINT,
-            Errors.InvalidOptimalUsageRatio()
+            Errors.INVALID_OPTIMAL_USAGE_RATIO
         );
 
         require(
             rateData.variableRateSlope1 <= rateData.variableRateSlope2,
-            Errors.Slope2MustBeGteSlope1()
+            Errors.SLOPE_2_MUST_BE_GTE_SLOPE_1
         );
 
         // The maximum rate should not be above certain threshold
         require(
             uint256(rateData.baseVariableBorrowRate) +
                 uint256(rateData.variableRateSlope1) +
                 uint256(rateData.variableRateSlope2) <=
                 MAX_BORROW_RATE,
-            Errors.InvalidMaxRate()
+            Errors.INVALID_MAX_RATE
         );
 
         _interestRateData[reserve] = rateData;
         emit RateDataUpdate(
