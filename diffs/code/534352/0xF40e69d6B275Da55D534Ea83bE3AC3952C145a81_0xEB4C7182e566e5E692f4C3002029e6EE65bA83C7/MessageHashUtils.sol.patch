Index: lib/solidity-utils/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/utils/cryptography/MessageHashUtils.sol
===================================================================
--- lib/solidity-utils/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/utils/cryptography/MessageHashUtils.sol
+++ lib/solidity-utils/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/utils/cryptography/MessageHashUtils.sol
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: MIT
-// OpenZeppelin Contracts (last updated v5.1.0) (utils/cryptography/MessageHashUtils.sol)
+// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/MessageHashUtils.sol)
 
 pragma solidity ^0.8.20;
 
 import {Strings} from "../Strings.sol";
@@ -8,14 +8,14 @@
 /**
  * @dev Signature message hash utilities for producing digests to be consumed by {ECDSA} recovery or signing.
  *
  * The library provides methods for generating a hash of a message that conforms to the
- * https://eips.ethereum.org/EIPS/eip-191[ERC-191] and https://eips.ethereum.org/EIPS/eip-712[EIP 712]
+ * https://eips.ethereum.org/EIPS/eip-191[EIP 191] and https://eips.ethereum.org/EIPS/eip-712[EIP 712]
  * specifications.
  */
 library MessageHashUtils {
     /**
-     * @dev Returns the keccak256 digest of an ERC-191 signed data with version
+     * @dev Returns the keccak256 digest of an EIP-191 signed data with version
      * `0x45` (`personal_sign` messages).
      *
      * The digest is calculated by prefixing a bytes32 `messageHash` with
      * `"\x19Ethereum Signed Message:\n32"` and hashing the result. It corresponds with the
@@ -29,17 +29,18 @@
      */
     function toEthSignedMessageHash(
         bytes32 messageHash
     ) internal pure returns (bytes32 digest) {
-        assembly ("memory-safe") {
+        /// @solidity memory-safe-assembly
+        assembly {
             mstore(0x00, "\x19Ethereum Signed Message:\n32") // 32 is the bytes-length of messageHash
             mstore(0x1c, messageHash) // 0x1c (28) is the length of the prefix
             digest := keccak256(0x00, 0x3c) // 0x3c is the length of the prefix (0x1c) + messageHash (0x20)
         }
     }
 
     /**
-     * @dev Returns the keccak256 digest of an ERC-191 signed data with version
+     * @dev Returns the keccak256 digest of an EIP-191 signed data with version
      * `0x45` (`personal_sign` messages).
      *
      * The digest is calculated by prefixing an arbitrary `message` with
      * `"\x19Ethereum Signed Message:\n" + len(message)` and hashing the result. It corresponds with the
@@ -60,9 +61,9 @@
             );
     }
 
     /**
-     * @dev Returns the keccak256 digest of an ERC-191 signed data with version
+     * @dev Returns the keccak256 digest of an EIP-191 signed data with version
      * `0x00` (data with intended validator).
      *
      * The digest is calculated by prefixing an arbitrary `data` with `"\x19\x00"` and the intended
      * `validator` address. Then hashing the result.
@@ -76,9 +77,9 @@
         return keccak256(abi.encodePacked(hex"19_00", validator, data));
     }
 
     /**
-     * @dev Returns the keccak256 digest of an EIP-712 typed data (ERC-191 version `0x01`).
+     * @dev Returns the keccak256 digest of an EIP-712 typed data (EIP-191 version `0x01`).
      *
      * The digest is calculated from a `domainSeparator` and a `structHash`, by prefixing them with
      * `\x19\x01` and hashing the result. It corresponds to the hash signed by the
      * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`] JSON-RPC method as part of EIP-712.
@@ -88,9 +89,10 @@
     function toTypedDataHash(
         bytes32 domainSeparator,
         bytes32 structHash
     ) internal pure returns (bytes32 digest) {
-        assembly ("memory-safe") {
+        /// @solidity memory-safe-assembly
+        assembly {
             let ptr := mload(0x40)
             mstore(ptr, hex"19_01")
             mstore(add(ptr, 0x02), domainSeparator)
             mstore(add(ptr, 0x22), structHash)
