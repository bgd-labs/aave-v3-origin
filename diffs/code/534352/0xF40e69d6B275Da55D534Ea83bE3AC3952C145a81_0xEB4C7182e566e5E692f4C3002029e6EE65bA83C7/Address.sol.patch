Index: lib/solidity-utils/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/utils/Address.sol
===================================================================
--- lib/solidity-utils/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/utils/Address.sol
+++ lib/solidity-utils/lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/utils/Address.sol
@@ -1,21 +1,29 @@
 // SPDX-License-Identifier: MIT
-// OpenZeppelin Contracts (last updated v5.1.0) (utils/Address.sol)
+// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)
 
 pragma solidity ^0.8.20;
 
-import {Errors} from "./Errors.sol";
-
 /**
  * @dev Collection of functions related to the address type
  */
 library Address {
     /**
+     * @dev The ETH balance of the account is not enough to perform the operation.
+     */
+    error AddressInsufficientBalance(address account);
+
+    /**
      * @dev There's no code at `target` (it is not a contract).
      */
     error AddressEmptyCode(address target);
 
     /**
+     * @dev A call to an address target failed. The target may have reverted.
+     */
+    error FailedInnerCall();
+
+    /**
      * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
      * `recipient`, forwarding all available gas and reverting on errors.
      *
      * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
@@ -31,14 +39,14 @@
      * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
      */
     function sendValue(address payable recipient, uint256 amount) internal {
         if (address(this).balance < amount) {
-            revert Errors.InsufficientBalance(address(this).balance, amount);
+            revert AddressInsufficientBalance(address(this));
         }
 
         (bool success, ) = recipient.call{value: amount}("");
         if (!success) {
-            revert Errors.FailedCall();
+            revert FailedInnerCall();
         }
     }
 
     /**
@@ -48,9 +56,9 @@
      *
      * If `target` reverts with a revert reason or custom error, it is bubbled
      * up by this function (like regular Solidity function calls). However, if
      * the call reverted with no returned reason, this function reverts with a
-     * {Errors.FailedCall} error.
+     * {FailedInnerCall} error.
      *
      * Returns the raw returned data. To convert to the expected return value,
      * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
      *
@@ -80,9 +88,9 @@
         bytes memory data,
         uint256 value
     ) internal returns (bytes memory) {
         if (address(this).balance < value) {
-            revert Errors.InsufficientBalance(address(this).balance, value);
+            revert AddressInsufficientBalance(address(this));
         }
         (bool success, bytes memory returndata) = target.call{value: value}(
             data
         );
@@ -114,10 +122,10 @@
     }
 
     /**
      * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target
-     * was not a contract or bubbling up the revert reason (falling back to {Errors.FailedCall}) in case
-     * of an unsuccessful call.
+     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an
+     * unsuccessful call.
      */
     function verifyCallResultFromTarget(
         address target,
         bool success,
@@ -136,9 +144,9 @@
     }
 
     /**
      * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the
-     * revert reason or with a default {Errors.FailedCall} error.
+     * revert reason or with a default {FailedInnerCall} error.
      */
     function verifyCallResult(
         bool success,
         bytes memory returndata
@@ -150,19 +158,20 @@
         }
     }
 
     /**
-     * @dev Reverts with returndata if present. Otherwise reverts with {Errors.FailedCall}.
+     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.
      */
     function _revert(bytes memory returndata) private pure {
         // Look for revert reason and bubble it up if present
         if (returndata.length > 0) {
             // The easiest way to bubble the revert reason is using memory via assembly
-            assembly ("memory-safe") {
+            /// @solidity memory-safe-assembly
+            assembly {
                 let returndata_size := mload(returndata)
                 revert(add(32, returndata), returndata_size)
             }
         } else {
-            revert Errors.FailedCall();
+            revert FailedInnerCall();
         }
     }
 }
